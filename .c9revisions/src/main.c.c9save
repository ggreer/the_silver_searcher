{"ts":1341796051015,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#include <pcre.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n\n#include \"log.h\"\n#include \"options.h\"\n#include \"search.h\"\n\n#include \"config.h\"\n\nint main(int argc, char **argv) {\n    set_log_level(LOG_LEVEL_WARN);\n\n    char **paths = NULL;\n    int i;\n    int pcre_opts = PCRE_MULTILINE;\n    int study_opts = 0;\n    const char *pcre_err = NULL;\n    int pcre_err_offset = 0;\n    pcre *re = NULL;\n    pcre_extra *re_extra = NULL;\n    double time_diff = 0.0;\n\n    memset(&stats, 0, sizeof(stats)); /* What's the point of an init function if it's going to be this one-liner? */\n\n    gettimeofday(&(stats.time_start), NULL);\n\n    parse_options(argc, argv, &paths);\n\n    log_debug(\"PCRE Version: %s\", pcre_version());\n\n    if (opts.casing == CASE_INSENSITIVE) {\n        pcre_opts = pcre_opts | PCRE_CASELESS;\n    }\n\n    if (!is_regex(opts.query)) {\n        opts.literal = 1;\n    }\n    if (opts.literal) {\n        generate_skip_lookup(opts.query, opts.query_len, skip_lookup, opts.casing == CASE_SENSITIVE);\n    }\n    else {\n        if (opts.whole_word) {\n            char* wholeWordQuery[strlen(opts.query) + 6];\n            strcat(wholeWordQuery, \"\\\\b\");\n            strcat(wholeWordQuery, opts.query);\n            strcat(wholeWordQuery, \"\\\\b\");\n            printf(\"wo %s\", wholeWordQuery);\n            re = pcre_compile(wholeWordQuery, pcre_opts, &pcre_err, &pcre_err_offset, NULL);\n        }\n        else {\n            re = pcre_compile(opts.query, pcre_opts, &pcre_err, &pcre_err_offset, NULL);\n        }\n        if (re == NULL) {\n            log_err(\"pcre_compile failed at position %i. Error: %s\", pcre_err_offset, pcre_err);\n            exit(1);\n        }\n\n#ifdef USE_PCRE_JIT\n        int has_jit = 0;\n        pcre_config(PCRE_CONFIG_JIT, &has_jit);\n        if (has_jit) {\n            study_opts |= PCRE_STUDY_JIT_COMPILE;\n        }\n#endif\n\n        re_extra = pcre_study(re, study_opts, &pcre_err);\n        if (re_extra == NULL) {\n            log_debug(\"pcre_study returned nothing useful. Error: %s\", pcre_err);\n        }\n    }\n\n    if (opts.search_stream) {\n        search_stdin(re, re_extra);\n    }\n    else {\n        for (i = 0; paths[i] != NULL; i++) {\n            log_debug(\"searching path %s for %s\", paths[i], opts.query);\n            search_dir(re, re_extra, paths[i], 0);\n            free(paths[i]);\n        }\n    }\n\n    if (opts.stats) {\n        gettimeofday(&(stats.time_end), NULL);\n        time_diff = ((long)stats.time_end.tv_sec * 1000000 + stats.time_end.tv_usec) -\n                    ((long)stats.time_start.tv_sec * 1000000 + stats.time_start.tv_usec);\n        time_diff = time_diff / 1000000;\n\n        printf(\"%ld matches\\n%ld files searched\\n%ld bytes searched\\n%f seconds\\n\", stats.total_matches, stats.total_files, stats.total_bytes, time_diff);\n    }\n\n    pcre_free(re);\n    pcre_free(re_extra); /* Using pcre_free_study here segfaults on some versions of PCRE */\n    free(paths);\n    cleanup_ignore_patterns();\n\n    return 0;\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":2989}]],"length":2989}
